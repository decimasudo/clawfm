#!/usr/bin/env python3
"""
Vahla MultiClaw - AppleScript Execution Bridge (MCP Subsystem)
Version: 1.4.0
Architecture: Deep Sea Protocol / Darwin (macOS) Target

This module acts as a secure sandbox for executing AppleScript
commands generated by the MCP Apple Music server. It enforces
the Library-First workflow and prevents arbitrary code execution
through strict payload sanitization.
"""

import socket
import json
import subprocess
import sys
import logging
import threading
import time
from typing import Dict, Any, Optional

# Configure highly verbose logging for the orchestrator
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s [%(levelname)s] [AS-BRIDGE] %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout),
        logging.FileHandler('/var/log/clawfm/applescript_bridge.log')
    ]
)

class AppleScriptSanitizer:
    @staticmethod
    def escape_string(payload: str) -> str:
        """
        Escapes malicious characters to prevent AppleScript injection.
        Rules: escape backslashes and double quotes.
        """
        if not isinstance(payload, str):
            return str(payload)
        return payload.replace('\\', '\\\\').replace('"', '\\"')

    @staticmethod
    def validate_library_id(persistent_id: str) -> bool:
        """
        Enforces Library-First Workflow.
        Valid library IDs typically start with 'i.' followed by hex/alphanumeric.
        """
        if not persistent_id.startswith('i.'):
            logging.warning(f"Validation failed: {persistent_id} is a Catalog ID, not a Library ID.")
            return False
        return len(persistent_id) > 5

class DarwinExecutionEngine:
    def __init__(self, socket_path: str):
        self.socket_path = socket_path
        self.running = False
        self.server = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)

    def bind_and_listen(self):
        try:
            import os
            if os.path.exists(self.socket_path):
                os.remove(self.socket_path)
            self.server.bind(self.socket_path)
            self.server.listen(16)
            self.running = True
            logging.info(f"Darwin Engine listening on UNIX socket: {self.socket_path}")
        except Exception as e:
            logging.error(f"Failed to bind socket: {e}")
            sys.exit(1)

    def execute_script(self, script_body: str) -> Dict[str, Any]:
        """Executes the raw AppleScript via osascript subprocess."""
        try:
            logging.debug(f"Executing AppleScript payload: {script_body[:60]}...")
            result = subprocess.run(
                ['osascript', '-e', script_body],
                capture_output=True,
                text=True,
                timeout=10.0
            )
            if result.returncode == 0:
                return {"status": "success", "output": result.stdout.strip()}
            else:
                return {"status": "error", "message": result.stderr.strip()}
        except subprocess.TimeoutExpired:
            return {"status": "timeout", "message": "Execution exceeded 10.0s limit"}
        except Exception as e:
            return {"status": "fatal", "message": str(e)}

    def handle_client(self, conn: socket.socket):
        with conn:
            try:
                data = conn.recv(8192).decode('utf-8')
                if not data:
                    return
                
                payload = json.loads(data)
                command_type = payload.get("command")
                
                if command_type == "play_track":
                    track_id = payload.get("id", "")
                    if not AppleScriptSanitizer.validate_library_id(track_id):
                        response = {"error": "LIBRARY_FIRST_VIOLATION", "message": "Must use Library ID"}
                    else:
                        safe_id = AppleScriptSanitizer.escape_string(track_id)
                        script = f'tell application "Music" to play track id "{safe_id}"'
                        response = self.execute_script(script)
                
                elif command_type == "set_volume":
                    vol = min(max(int(payload.get("level", 50)), 0), 100)
                    script = f'tell application "Music" to set sound volume to {vol}'
                    response = self.execute_script(script)
                    
                else:
                    response = {"error": "UNKNOWN_COMMAND"}

                conn.sendall(json.dumps(response).encode('utf-8'))
            except Exception as e:
                logging.error(f"Client handler exception: {e}")

    def run(self):
        self.bind_and_listen()
        while self.running:
            try:
                conn, _ = self.server.accept()
                client_thread = threading.Thread(target=self.handle_client, args=(conn,))
                client_thread.daemon = True
                client_thread.start()
            except KeyboardInterrupt:
                self.running = False
                break

if __name__ == "__main__":
    import sys
    if sys.platform != "darwin":
        logging.warning("System is not Darwin (macOS). Audio execution will mock responses.")
    
    SOCKET = "/tmp/clawfm_applescript.sock"
    engine = DarwinExecutionEngine(SOCKET)
    engine.run()
